---
title: 前n个数字二进制中 1 的个数
categories: 
- 算法
- 动态规划
tags:
- 算法
- 动态规划
date: 2023-01-12 10:21:34
---

## 题目描述

给定一个非负整数 n ，请计算 0 到 n 之间的每个数字的二进制表示中 1 的个数，并输出一个数组。

 示例 1:

> 输入: n = 2
> 输出: [0,1,1]
> 解释: 
> 0 --> 0
> 1 --> 1
> 2 --> 10

示例 2:

>输入: n = 5
>输出: [0,1,1,2,1,2]
>解释:
>0 --> 0
>1 --> 1
>2 --> 10
>3 --> 11
>4 --> 100
>5 --> 101


说明 :

0 <= n <= 105


进阶:

给出时间复杂度为 O(n*sizeof(integer)) 的解答非常容易。但你可以在线性时间 O(n) 内用一趟扫描做到吗？
要求算法的空间复杂度为 O(n) 。
你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount ）来执行此操作。

## 题解

### 内置函数解决

> 先只能想到通过内置函数转换成二进制，然后数数的方式解决，想不到用动态规划。

```python
class Solution:
    def countBits(self, n: int) -> List[int]:
        outlist = []
        for i in range(n+1):
            outlist.append("{0:b}".format(i).count('1'))  # 这里的"{0:b}".format(i) 是将十进制i转换成二进制字符表示的方法
        return outlist
```

### 动态规划方式解决

> 实际上对动态规划还不太熟悉，很难想到用这个方式来解答，况且对二进制中的位运算来消除1的方式也想不到，通过看解答，最终理解了这个方法的一些原理，动态规划感觉也是一种递推的方法，同归对简单问题的逐步递推，最终得到想要问题的最优解，前面每一步的递推结果都是后面结果获取的依据，所以在动态规划中，核心就是找到递推公式。

```python
class Solution:
    def countBits(self, n: int) -> List[int]:
        # 将dp数组全部初始化为0，实际上dp[0]=0就是后面其他数得到1个数的基础了
        dp = [0] * (n + 1)
        for i in range(1, n + 1):
            # 下面这一句感觉难理解，i & (i - 1) 实际就是消除i二进制表示中的最低位的1，而+1则正好把消除的那个1补回来，正好就是i当前理应有的1的个数，实际就是这样递推出来的。
            dp[i] = dp[i & (i - 1)] + 1
        return dp
```

- 这个方法妙就妙在这个递推公式`   dp[i] = dp[i & (i - 1)] + 1` 通过i & (i - 1) 这个式子来消除i二进制表示中的最低位的1，从而得到的是`i-1`也就是前面一个数该有的1的个数，那么这个数再加上一个1不就应该是i这个数该有的1的数量么？
- 可能还是有点难理解，动态规划的核心思想就是当前i的值，是通过上一个数i-1的值递推而来，关键就是如何找到这个递推规律了。



